\chapter{Motivation}
\label{ch:motivation}

This chapter discusses the need of doing the Thesis. \\ \\

Static Analysis plays a prominent role in releasing bug-free Software. In spite of their important tools suffer from well-documented usability issues \cite{CB16,JSMB13}.  Maria et. al. \cite{CB16} did an empirical study on what developers want and need from Program Analysis. They noticed that there are some obstacles which hinder the usage of a Static Analysis tool by a developer such as Wrong checks are on by default, Too many false positives, Too slow,  Complex user interface etc. Being UI an obstacle for a developer is noteworthy. Johnson et. al. \cite{JSMB13} also found design flaws in current Static Analysis tools and the need for an interactive mechanism in assisting developers in fixing bugs. One interesting aspect of their study is about the importance of feedback from tools without disrupting the developer workflow. \\

Overall, let us focus on the two aspects mentioned in the above-cited papers i.e., the more time is taken by Analysis tool and Design issues. Regarding the aspect of time, the research is going at a fast pace to make modern Analysis tool capable of producing the results in less time. The Static Analysis mechanisms are evolved from standard mechanisms towards incremental analysis such as ACINF, ACINB Data Flow Analysis tools then to layered analysis, promising the reduction in time for computation. For example,  an incremental Static Analysis tool named iSATURN \cite{iSaturn} which is built on leveraging the path abstraction properties of SATURN \cite{Xie} Analysis tool promised to show a 32\% reduction in analysis time. Another example, a layered analysis tool called Cheetah \cite{JIT} which is a Just-in-Time Taint Analysis for Android applications produce analysis results in less than a second. This shows modern tools are capable of giving results in no time. In this way, it is evident the computation time mentioned as a hurdle will be overcome in the near future when these tools start coming into the market. Next, about design, there is a need for better user interfaces of these tools which go in parallel to the development made in Static Analysis mechanisms to really put into practice by end users. \\

In the design aspect, especially the User Interface needs to be responsive \cite{NB18} enough as static analysis tools sometimes take a long time to stop and there is no intuitive feedback provided. Back in the history of Computer Science, there is an observation made when the user interface is non-responsive, the user shuts down the system. Thereafter, comes to the implementation of user interface called Ghost screen by Colleran et al. \cite{colleran} who patented the method which manages application programs with non-responsive user interfaces in the year 2005. About the response times, NN Group \cite{nn} states that if the execution of a certain task takes 0.1 up to 1 second then there is no need for feedback, just show the result. If it takes 10 seconds, there should be feedback and if it is variable every time then there is the importance of percent bar \cite{Borman} but sometimes it could be overkill to use as it cause stress to the user by the principle of display inertia. If the time taken by a task is unknown then there has to be feedback like a spinning ball or in an example of a task being to scan databases then it has to report user what database is being scanned currently. Overall, there has to be feedback stating that the system is working, if not indicating what is actually doing. This motivates to know how responsiveness is vital to consider in the development of modern tools. \\

In general, the setup of most of the research done in the area of Static Code Analysis is like assuming a single project in an organisation. Further, they assume there is a single person working on a single project with a single tool tackling a single type of problems.  Somehow, the assumptions are made so singular to address a specific issue in their research. However, in practice i.e., in the real world of software engineering, there are numerous people working in teams for multiple projects at a time. Each project uses multiple tools in their software development. Even in the case of Static Code Analysis, multiple tools are used which are each capable of addressing several types of issues. \\

In the current scenario, we could see that usage of multiple tools in the Software Industry where each tool is different in computation approaches as one could be standard run on Nightly builds for example with Checkmarx \cite{checkmarx} tool or could be following Incremental Analysis. The multiplicity of tools usage and that too with different computation capabilities brings a new challenge.  One tool could produce results in no time and others could take more time in comparison. On that challenge, this Thesis aims to address such a scenario with an overall Research Question as " How to integrate the results of multiple static analysis tools? ". \\

The main research question is dissected into 3 research questions to make it more precise. Firstly, How to display results from the same codebase from different analysis tools?  This question needs to address the scalability aspect and what could be the impact of one fix be on other warnings. Secondly, What feedback works to know that the bug fixing is on-going? This question needs to address the scenario where one tool could give an instant update on the bug fixing process and others might take more time to analyse and report the update on it. Finally, How to carry traceability of bug fixing? In the scenario, where the user has picked a bug to fix and worked on it and later he submitted for analysis. Then the bug could either get fixed or new bugs could have been introduced or different bugs got resolved by fixing the one bug. All these might have taken place and this is uncertain. Thereby it would be better to have traceability in order to somehow safeguard the code repository from future bugs or monitor the changes happening in the context of bugs. \\

In order to tackle these research questions, different disciplines of software engineering such as Complex datasets \cite{Dix}, \cite{Ruan}, \cite{Gaur}, Compiler reporting \cite{horning}, \cite{Sun}, \cite{Yannis}, Continuous integration \cite{Stahl} ( example Travis \cite{Beller}, \cite{Gallaba}, \cite{Widder}), Refactoring tools \cite{dustinca}, \cite{Hayashi}, \cite{Mealy}, \cite{Pinto}, Issue tracker \cite{Baysal}, \cite{Jayarajah}, \cite{Raza}, StackOverflow \cite{stack} \cite{Treude.2011}, Gamification \cite{gamify} , Usability Engineering \cite{usability} etc. are looked into and studied what ideas can be adapted into our scenario along with own novel solution ideas. \\ \\

\let\cleardoublepage\clearpage
